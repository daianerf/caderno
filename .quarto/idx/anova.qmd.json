{"title":"**ANOVA** (Análise de Variância)","markdown":{"yaml":{"format":"html","editor":"visual"},"headingText":"**ANOVA** (Análise de Variância)","containsRefs":false,"markdown":"\n\n\nÉ um teste estatístico utilizado para comparar as médias de três ou mais grupos e verificar se há diferenças estatisticamente significativas entre elas. Ao invés de comparar pares de médias individualmente, como no teste t, a ANOVA avalia simultaneamente a variabilidade entre os grupos e dentro dos grupos.\n\nA ANOVA usa o teste F para testar a hipótese nula de que as médias populacionais são iguais contra a hipótese alternativa de que pelo menos uma média é diferente das demais.\n\n## **Anova com 1 fator (***One-way Anova*)\n\nÉ uma técnica estatística utilizada para comparar as médias de três ou mais grupos que diferem em relação a um único fator (ou variável independente). Esse fator pode representar, por exemplo, diferentes tratamentos, cultivares, doses de um produto ou condições experimentais.\n\nO objetivo é verificar se há diferença significativa entre as médias dos grupos. A hipótese nula assume que todas as médias são iguais, enquanto a hipótese alternativa indica que pelo menos uma delas é diferente.\n\n**Exemplo:** Experimento com um fator e em delineamento inteiramente casualizado (DIC) para comparar o crescimento micelial de diferentes espécies de um fungo fitopatogênico. A resposta a ser estudada é a TCM = taxa de crescimento micelial.\n\n### Importando o conjunto de dados:\n\n```{r}\nlibrary(readxl)\nmicelial <- read_excel(\"dados-diversos.xlsx\", \"micelial\")\nhead(micelial)\n```\n\n### Carregando pacotes:\n\n```{r}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n\n### **Visualização dos dados**:\n\n```{r}\nmicelial |>\n  ggplot(aes(x = especie, y = tcm)) +\n  geom_boxplot(utlier.color = NA, fill = \"#1A8C8C\", color = \"black\") +\n   geom_jitter(width = 0.1)+\n  labs(\n    x = \"Espécie Fúngica\",\n    y = \"Taxa de Crescimento Micelial\"\n  )\n```\n\n### **Modelo usando `aov()`**\n\nPara verificar os dados usando anova, um novo modelo para atribuir a função `aov()` contendo os argumentos tratamento em função da variável resposta deve ser criado (ex.: tcm \\~ espécie), o banco de dados referido deve ser enunciado após o argumento separado por vírgula seguido do nome data = nome do conjunto de dados (ex.: micelial). Depois disso, pede um quadro de resumo do novo modelo criado.\n\n```{r}\naov1 <- aov(tcm ~ especie, data = micelial)\nsummary(aov1)\n```\n\n```{r}\naov2 <- lm(tcm ~ especie, data = micelial) # Outra forma de fazer a ANOVA\naov2\n```\n\n#### **Testando as premissas**\n\n##### **Testes de Normalidade e Homocedasticidade**\n\n**Teste de Normalidade**\n\nA normalidade dos dados é uma condição importante para muitos testes estatísticos. Ela garante que os resultados das análises, como ANOVA e teste t, sejam confiáveis, pois esses métodos assumem que os dados vêm de uma população com distribuição normal.\n\n**Teste de Homocedasticidade**\n\nNa ANOVA, é necessário que os grupos comparados tenham variâncias semelhantes. Essa condição é chamada de homocedasticidade. Se as variâncias forem muito diferentes (heterocedasticidade), os resultados do teste F podem ser comprometidos.\n\nPara testar as premissas, é necessário instalar e carregar o pacote `performance` e o pacote `DHARMa`.\n\nO pacote `performance` permite checar as premissas `(check_)`, já o pacote `DHARMA` (*Distributed Hierarchical Accumulation of Residuals for Generalized Linear Models in R*) é para visualizar os dados pelo diagnóstico do resíduo. O pacote `DHARMa` permite faz uma comparação dos resíduos simulados, que são gerados pelo pacote, com os resíduos observados e ver graficamente quando a distribuição dos dados não é normal e/ou quando há variação heterocedástica.\n\nApós isso, deve-se fazer o teste de normalidade dos resíduos com a interação entre a anova e os resíduos.\n\n```{r}\nlibrary(performance)\ncheck_heteroscedasticity(aov1)\n```\n\n```{r}\ncheck_normality(aov1)\n```\n\n```{r}\nlibrary(DHARMa)\nhist (aov1$residuals) #Ou hist(residuals(aov1))\n\n# Mostra a distribuição visual dos resíduos.\n```\n\n```{r}\nqqnorm(aov1$residuals)\nqqline(aov1$residuals)\n```\n\n```{r}\nplot(simulateResiduals(aov1))\n```\n\n```{r}\nshapiro.test(aov1$residuals) #Ou shapiro.test(residuals(aov1)) \n```\n\nO teste verifica a seguinte hipótese:\n\n-   **Hipótese nula (H₀)**: Os dados seguem distribuição normal;\n\n-   **Hipótese alternativa (H₁)**: Os dados não seguem distribuição normal.\n\nComparamos o p-valor com um nível de significância comum, geralmente **α = 0,05**:\n\n**p-valor = 0,8782 \\> 0,05** → Não rejeitamos a hipótese nula\n\nHomogeneidade de variâncias:\n\n```{r}\n# Teste de Bartlett – mais sensível a desvios da normalidade\nbartlett.test(tcm ~ especie, data = micelial)\n```\n\n```{r}\n# Teste de Levene – mais robusto à violação da normalidade\nlibrary(car)\nleveneTest(tcm ~ especie, data = micelial)\n```\n\n##### Interpretação dos Resultados:\n\n-   **p-valor \\> 0,05** → Não há evidência de variâncias diferentes → Premissa atendida.\n\n-   **p-valor \\< 0,05** → As variâncias são significativamente diferentes → Premissa violada.\n\n#### Comparações múltiplas e médias ajustadas\n\n**Pacote “emmeans”**\n\n(“*estimated marginal means*”, ou médias marginais estimadas) é usado para realizar testes de comparação de médias entre grupos, ajustando para outros fatores importantes que podem influenciar as médias. O pacote é particularmente útil em modelos lineares generalizados (GLM).\n\n`emmeans(...)`: calcula as médias ajustadas (médias marginais) para cada grupo de `especie` com base no modelo.\n\nImportante para comparações entre grupos quando há mais de 2 níveis.\n\n```{r}\nlibrary(emmeans)\nm <- emmeans(aov2, ~ especie)\nm\n```\n\n**Testes post-hoc (comparações entre grupos)**\n\n**Pacote “multcomp” -** `multcomp`: para fazer comparações múltiplas entre grupos.\n\nTestes simultâneos e intervalos de confiança para hipóteses lineares gerais em modelos paramétricos, incluindo efeitos lineares, lineares generalizados, lineares mistos e modelos de sobrevivência.\n\n**Pacote “multcompView” -** `multcompView`: para gerar **letras compactas**, indicando quais grupos são diferentes.\n\nConverte um vetor lógico ou um vetor de valores-*p* ou uma matriz de correlação, diferença ou distância em uma exibição identificando os pares para os quais as diferenças não foram significativamente diferentes.\n\n**Cld -** Extrai e exibe informações sobre todas as comparações pareadas de médias de mínimos quadrados.\n\n```{r}\nlibrary(multcomp)\nlibrary(multcompView)\n\ncld(m)\n```\n\n```{r}\npairs(m) #Mostra os testes pareados (comparação entre pares de grupos).\n```\n\n```{r}\npwpm(m) #Exibe uma matriz com as médias na diagonal e comparações entre os grupos fora dela.\n```\n\n## ANOVA fatorial (two-way ANOVA)\n\nA ANOVA fatorial é utilizada quando há duas ou mais variáveis independentes (fatores), cada uma com dois ou mais níveis. Ela é apropriada para experimentos fatoriais completos, nos quais todas as combinações possíveis entre os níveis dos fatores são testadas. Além de avaliar os efeitos individuais de cada fator, essa análise também permite verificar se existe interação entre os fatores, ou seja, se o efeito de um fator depende dos níveis do outro.\n\n### Importando o conjunto de dados:\n\nBanco de dados utilizado: fungicida-vaso (conjunto de dados do dados diversos). Objeto nomeado como fung_vaso.\n\n```{r}\nlibrary(tidyverse)\nlibrary(readxl)\n\nfung_vaso <- read_xlsx(\"dados-diversos.xlsx\", sheet = \"fungicida_vaso\")\n```\n\n**`factor(dose)`**: converte a variável `dose` em fator (categórica);\n\n**`severity * 100`**: transforma a variável de severidade em percentual;\n\n**`geom_jitter()`**: mostra os pontos com leve deslocamento horizontal, evitando sobreposição;\n\n**`facet_wrap(~ treat)`**: separa os gráficos por tratamento (`treat`).\n\n```{r}\nfung_vaso |> \n  ggplot(aes(factor(dose), severity*100))+ #transformando dose em um fator e ##transformar para percentual *100\n  geom_jitter(width = 0.1)+\n  facet_wrap(~ treat)\n```\n\n### Modelo linear com interação\n\n```{r}\nm_anti <- lm(severity ~ treat * dose, data = fung_vaso)\nanova(m_anti)\n```\n\n#### Checagem das premissas e visualização com DHARMa:\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m_anti))\n```\n\n#### Médias ajustadas com `emmeans`\n\n```{r}\nmedia_anti <- emmeans(m_anti, ~ treat | dose)\nmedia_anti\n```\n\n#### Comparações múltiplas\n\n```{r}\ncld(media_anti)\n```\n\n##### Agora inverte: médias de doses dentro de tratamentos\n\n```{r}\nmedia_anti <- emmeans(m_anti, ~ dose | treat)\nmedia_anti\ncld(media_anti)\n```\n\n#### Coeficiente de variação\n\nEssa função do pacote `agricolae` calcula o coeficiente de variação (CV%) do modelo.\n\nAjuda a avaliar a precisão experimental. Valores abaixo de 20% geralmente são considerados bons (mas depende do contexto).\n\n```{r}\nlibrary(agricolae)\ncv.model(m_anti)\n```\n\n#### E se não houver interação significativa?\n\nMostra os efeitos **individuais de dose e tratamento**, ignorando a interação.\n\n```{r}\nlibrary(patchwork)\n\np1 <- fung_vaso |> \n  ggplot(aes(factor(dose), severity*100)) + \n  geom_jitter(width = 0.1)\np2 <- fung_vaso |> \n  ggplot(aes(treat, severity*100)) + \n  geom_jitter(width = 0.1)\np1 + p2\n```\n\n#### Visualização da interação\n\n-   Gera um gráfico de interação;\n\n-   Se as linhas forem paralelas, não há interação;\n\n-   Se forem cruzadas ou afastadas, pode indicar interação.\n\n```{r}\ninteraction.plot(fung_vaso$treat, fung_vaso$dose, fung_vaso$severity)\n```\n\nTabela\n\n|          | 0.5     | 0.2    |\n|----------|---------|--------|\n| LI       | 29.2 Aa | 5.0 Ab |\n| TEBU     | 2.1 Ba  | 2.0 Aa |\n| cv = 63% |         |        |\n\n### Exemplo:\n\n#### Pacote `epifitter` e dados:\n\n```{r}\n#install.packages(\"epifitter\")\nlibrary(epifitter)\noidio <- PowderyMildew\n```\n\n#### Visualização dos dados filtrados\n\nFiltra apenas 3 tipos de irrigação.\n\n`sev*100`: transforma a severidade (que vai de 0 a 1) para percentual (0–100%).\n\n`facet_grid(moisture ~ irrigation_type)`: cria um painel com um gráfico para cada combinação de `moisture` (umidade) e `irrigation_type` (tipo de irrigação).\n\nO gráfico mostra como a doença evolui ao longo do tempo (`time`).\n\n```{r}\noidio |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\")) |> \n  ggplot(aes(time, sev*100)) + \n  geom_jitter(width = 0.1) +\n  facet_grid(moisture ~ irrigation_type)\n```\n\n#### Cálculo da AUDPC (Área Abaixo da Curva de Progresso da Doença)\n\n`group_by(...)` agrupa os dados por tratamento (irrigação, umidade e bloco);\n\n`AUDPC(...)` calcula a área abaixo da curva para cada grupo;\n\nA AUDPC resume a intensidade da doença ao longo do tempo.\n\n```{r}\nlibrary(dplyr)\nlibrary(epifitter)\n\noidio3 <- oidio |>\n  group_by(irrigation_type, moisture, block) |>\n  summarise(AUDPC = AUDPC(time, sev), .groups = \"drop\")\n```\n\n#### Visualizando a AUDPC\n\n```{r}\noidio3 |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\")) |>\n  ggplot(aes(irrigation_type, AUDPC, color = moisture)) +\n  geom_point(width = 0.1) +\n  scale_y_continuous(limits = c(0, 20))\n```\n\n#### ANOVA fatorial (efeito da irrigação e umidade na AUDPC)\n\n```{r}\noidio4 <- oidio3 |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\"))\n\nanov_oidio <- lm(AUDPC ~ irrigation_type * moisture, data = oidio4)\nanova(anov_oidio)\n```\n\n#### Diagnóstico do modelo\n\n```{r}\nplot(simulateResiduals(anov_oidio))\n```\n\n#### Médias ajustadas com `emmeans`\n\n```{r}\nmedias_oidio <- emmeans(anov_oidio, ~ irrigation_type | moisture)\nmedias_oidio\ncld(medias_oidio)\n```\n\nAgora, inverte: mostra as médias de umidade dentro de cada tipo de irrigação.\n\n```{r}\nmedias_oidio2 <- emmeans(anov_oidio, ~ moisture | irrigation_type)\nmedias_oidio2\ncld(medias_oidio2)\n```\n\n#### Coeficiente de variação do modelo\n\nIndica a precisão do experimento - valores menores geralmente indicam maior confiabilidade\n\n```{r}\ncv.model(anov_oidio)\n```\n\nTabela\n\n|           | H. moisture | M. moisture |\n|-----------|-------------|-------------|\n| MS        | 8.52 Aa     | 11.18 Ab    |\n| MS Ac.    | 3.99 Ba     | 4.86 Bb     |\n| Overhead  | 3.68 Ba     | 3.81 Ca     |\n| CV = 6.41 |             |             |\n\n## Anova Fatorial - 3 Fatores\n\n### Exemplo:\n\nDados sobre a interação entre tipo de armazenamento e umidade.\n\n```{r}\nmilho <- read_excel(\"dados-diversos.xlsx\", \"armazena\")\nmilho |>\n  filter(tempo ==8) |>\n  ggplot(aes(factor(tipo), peso_mil,\n             color = factor(umidade)))+\n  geom_jitter(width = 0.1)+\n  facet_wrap(~ umidade)\n```\n\nTestar a interação entre o tipo de armazenamento e o tempo 8\n\n```{r}\nmilho2 <- milho |>\n  filter(tempo ==8)\n\nm2 <- aov(peso_mil ~ factor(tipo)*factor(umidade),\n          data = milho2)\nsummary(m2)\n```\n\nTestanto tipo de inoculação na incidencia de *Fusarium* sp. em milho\n\n```{r}\nmilho3 <- read_excel(\"dados-diversos.xlsx\", \"milho\")\n\nm4 <- aov(yield ~hybrid*method,\n          data = milho3)\nsummary(m4)\n```\n\nChecagem das premissas\n\n```{r}\ncheck_heteroscedasticity(m4)\n```\n\n```{r}\nplot(simulateResiduals(m4))\n```\n\nMédias ajustadas com `emmeans`\n\n```{r}\nmedias_m4 <- emmeans(m4, ~ hybrid)\nmedias_m4\n```\n\n```{r}\ncld(medias_m4)\n```\n\nCaso a interação não dê sifnificativa, tira a interação e deixa só o fator que teve significancia (isola o fator)\n\n```{r}\nm5 <- aov(yield ~hybrid, data = milho3)\nsummary(m5)\n```\n\n```{r}\nm4 <- aov(yield ~hybrid,\n          data = milho3)\nsummary(m5)\n```\n\n```{r}\ncheck_heteroscedasticity(m5)\n```\n\n```{r}\nmedias_m5 <- emmeans(m5, ~hybrid)\nmedias_m5\n```\n\n```{r}\ncld(medias_m5)\n```\n\n```{r}\npwpm(medias_m5)\n```\n\n## **ANOVA com bloco**\n\n### **Anova com bloco - Delineamento em Blocos Casualizado (DBC)**\n\nO (DBC) envolve os três princípios da experimentação: repetição, casualização e controle local. Neste caso, as condições locais não são homogêneas e podem ter efeito significativo sobre os tratamentos.\n\n#### Carregando pacotes e dados\n\nUsando o conjunto de dados fungicida_campo\n\n```{r}\nlibrary(readxl)\nlibrary(Hmisc)\nfung_campo <- read_xlsx(\"dados-diversos.xlsx\", sheet = \"fungicida_campo\")\n```\n\n#### Gráfico de produção por tratamento\n\n`mutate(TRAT = factor(TRAT))`: transforma os tratamentos (TRAT) em fatores para garantir que o `ggplot` os trate como categorias.\n\n`geom_jitter`: mostra os dados de cada parcela/bloco, deslocados horizontalmente para evitar sobreposição.\n\n`stat_summary(fun.data = \"mean_cl_boot\")`: adiciona médias com intervalos de confiança via bootstrap.\n\n```{r}\nfung_campo |> \n  mutate(TRAT = factor(TRAT)) |> \n  ggplot(aes(TRAT, PROD)) +\n  geom_jitter(width = 0.2) +\n  stat_summary(fun.data = \"mean_cl_boot\", colour = \"red\", width = 0.3)\n\n```\n\n#### Convertendo variáveis em fatores\n\nAqui, você transforma `TRAT` e `BLOCO` explicitamente em **fatores**, pois o R trata números como contínuos por padrão.\n\n```{r}\nfung_campo$TRAT <- factor(fung_campo$TRAT)\nfung_campo$BLOCO <- factor(fung_campo$BLOCO)\n```\n\n#### **Modelo Anova com bloco**\n\nANOVA com efeito de blocos e tratamentos:\n\n```{r}\nanova_campo <- lm(PROD ~ BLOCO + TRAT, data = fung_campo)\nanova(anova_campo)\n\n```\n\n#### Checagem das premissas\n\n```{r}\nlibrary(performance)\nlibrary(DHARMa)\ncheck_normality(anova_campo)\ncheck_heteroscedasticity(anova_campo)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(anova_campo))\n```\n\n#### Estimativa e comparação das médias dos tratamentos\n\n```{r}\nmeans_campo <- emmeans(anova_campo, ~ TRAT)\nmeans_campo\n```\n\n```{r}\nlibrary(multcomp)\ncld(means_campo)\n```\n\n```{r}\nplot(means_campo)\npwpp(means_campo)\npwpm(means_campo)\n```\n\nAnálise da Severidade da Ferrugem (`FER`):\n\n#### ANOVA com transformação logarítmica\n\n```{r}\nanova_fer <- lm(log(FER) ~ BLOCO + TRAT, data = fung_campo)\nanova(anova_fer)\n```\n\n#### Diagnóstico do modelo\n\n```{r}\nplot(simulateResiduals(anova_fer))\n```\n\n#### Médias com back-transformation\n\n```{r}\nmeans_fer <- emmeans(anova_fer, ~ TRAT, type = \"response\")\n```\n\n```{r}\ncld(means_fer)\nplot(means_fer)\npwpp(means_fer)\npwpm(means_fer)\n```\n\n## **Delineamento em parcela subdividida (*Split-plot*)**\n\n### Importando o conjunto de dados:\n\nExemplo:\n\n```{r}\nmilho <- read_excel(\"dados-diversos.xlsx\", \"milho\")\n```\n\n#### Visualizando os dados\n\n```{r}\nmilho |> \n  \n  ggplot(aes(hybrid, index, color = method))+\n  geom_jitter(width = 0.1)+\n coord_flip()\n```\n\n#### **Ajustando o modelo**:\n\n```{r}\naov_milho_bloco <- aov(index ~ factor(block) + hybrid*method + \nError(factor(block)/hybrid/method), data = milho)\n\nsummary(aov_milho_bloco)\n```\n\n#### **Checagem das premissas**\n\nEm parcelas subdivididas não é possível checar as premissas pelo check\\_, então usa lme4, para checar pelo modelo misto.\n\n##### **Pacote “lme4”**\n\nAjusta modelos de efeitos mistos lineares e lineares generalizados. Os modelos e seus componentes são representados usando classes e métodos S4.\n\n##### **Função “lmer”**\n\nGera um componente aleatório que é específico a cada indivíduo, de modo que podemos ter, para cada um, um intercepto e uma inclinação distintas.\n\n```{r}\nlibrary(Matrix)\nlibrary(lme4)\nmilho$block <- as.factor(milho$block)\nmix2 <- lmer(index ~ block + hybrid*method + \n(1|block/hybrid), data =  milho)\n\nlibrary(car)\nAnova(mix2)\n```\n\n```{r}\ncheck_normality(mix2)\n```\n\n```{r}\ncheck_heteroscedasticity(mix2)\n```\n\n#### Necessário transformar os dados\n\n```{r}\nmilho$block <- as.factor(milho$block)\nmix2 <- lmer(sqrt(index) ~ block + hybrid*method + (1|block/hybrid), data = milho)\nlibrary(car)\nAnova(mix2)\n```\n\n##### Checagem\n\n```{r}\ncheck_normality(mix2)\n```\n\n```{r}\ncheck_heteroscedasticity(mix2)\n```\n\n#### **Comparação de médias**\n\n```{r}\nmeans_mix2 <- emmeans(mix2, ~hybrid | method)\nmeans_mix2\n```\n\n```{r}\ncld(means_mix2)\n```\n","srcMarkdownNoYaml":"\n\n# **ANOVA** (Análise de Variância)\n\nÉ um teste estatístico utilizado para comparar as médias de três ou mais grupos e verificar se há diferenças estatisticamente significativas entre elas. Ao invés de comparar pares de médias individualmente, como no teste t, a ANOVA avalia simultaneamente a variabilidade entre os grupos e dentro dos grupos.\n\nA ANOVA usa o teste F para testar a hipótese nula de que as médias populacionais são iguais contra a hipótese alternativa de que pelo menos uma média é diferente das demais.\n\n## **Anova com 1 fator (***One-way Anova*)\n\nÉ uma técnica estatística utilizada para comparar as médias de três ou mais grupos que diferem em relação a um único fator (ou variável independente). Esse fator pode representar, por exemplo, diferentes tratamentos, cultivares, doses de um produto ou condições experimentais.\n\nO objetivo é verificar se há diferença significativa entre as médias dos grupos. A hipótese nula assume que todas as médias são iguais, enquanto a hipótese alternativa indica que pelo menos uma delas é diferente.\n\n**Exemplo:** Experimento com um fator e em delineamento inteiramente casualizado (DIC) para comparar o crescimento micelial de diferentes espécies de um fungo fitopatogênico. A resposta a ser estudada é a TCM = taxa de crescimento micelial.\n\n### Importando o conjunto de dados:\n\n```{r}\nlibrary(readxl)\nmicelial <- read_excel(\"dados-diversos.xlsx\", \"micelial\")\nhead(micelial)\n```\n\n### Carregando pacotes:\n\n```{r}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n\n### **Visualização dos dados**:\n\n```{r}\nmicelial |>\n  ggplot(aes(x = especie, y = tcm)) +\n  geom_boxplot(utlier.color = NA, fill = \"#1A8C8C\", color = \"black\") +\n   geom_jitter(width = 0.1)+\n  labs(\n    x = \"Espécie Fúngica\",\n    y = \"Taxa de Crescimento Micelial\"\n  )\n```\n\n### **Modelo usando `aov()`**\n\nPara verificar os dados usando anova, um novo modelo para atribuir a função `aov()` contendo os argumentos tratamento em função da variável resposta deve ser criado (ex.: tcm \\~ espécie), o banco de dados referido deve ser enunciado após o argumento separado por vírgula seguido do nome data = nome do conjunto de dados (ex.: micelial). Depois disso, pede um quadro de resumo do novo modelo criado.\n\n```{r}\naov1 <- aov(tcm ~ especie, data = micelial)\nsummary(aov1)\n```\n\n```{r}\naov2 <- lm(tcm ~ especie, data = micelial) # Outra forma de fazer a ANOVA\naov2\n```\n\n#### **Testando as premissas**\n\n##### **Testes de Normalidade e Homocedasticidade**\n\n**Teste de Normalidade**\n\nA normalidade dos dados é uma condição importante para muitos testes estatísticos. Ela garante que os resultados das análises, como ANOVA e teste t, sejam confiáveis, pois esses métodos assumem que os dados vêm de uma população com distribuição normal.\n\n**Teste de Homocedasticidade**\n\nNa ANOVA, é necessário que os grupos comparados tenham variâncias semelhantes. Essa condição é chamada de homocedasticidade. Se as variâncias forem muito diferentes (heterocedasticidade), os resultados do teste F podem ser comprometidos.\n\nPara testar as premissas, é necessário instalar e carregar o pacote `performance` e o pacote `DHARMa`.\n\nO pacote `performance` permite checar as premissas `(check_)`, já o pacote `DHARMA` (*Distributed Hierarchical Accumulation of Residuals for Generalized Linear Models in R*) é para visualizar os dados pelo diagnóstico do resíduo. O pacote `DHARMa` permite faz uma comparação dos resíduos simulados, que são gerados pelo pacote, com os resíduos observados e ver graficamente quando a distribuição dos dados não é normal e/ou quando há variação heterocedástica.\n\nApós isso, deve-se fazer o teste de normalidade dos resíduos com a interação entre a anova e os resíduos.\n\n```{r}\nlibrary(performance)\ncheck_heteroscedasticity(aov1)\n```\n\n```{r}\ncheck_normality(aov1)\n```\n\n```{r}\nlibrary(DHARMa)\nhist (aov1$residuals) #Ou hist(residuals(aov1))\n\n# Mostra a distribuição visual dos resíduos.\n```\n\n```{r}\nqqnorm(aov1$residuals)\nqqline(aov1$residuals)\n```\n\n```{r}\nplot(simulateResiduals(aov1))\n```\n\n```{r}\nshapiro.test(aov1$residuals) #Ou shapiro.test(residuals(aov1)) \n```\n\nO teste verifica a seguinte hipótese:\n\n-   **Hipótese nula (H₀)**: Os dados seguem distribuição normal;\n\n-   **Hipótese alternativa (H₁)**: Os dados não seguem distribuição normal.\n\nComparamos o p-valor com um nível de significância comum, geralmente **α = 0,05**:\n\n**p-valor = 0,8782 \\> 0,05** → Não rejeitamos a hipótese nula\n\nHomogeneidade de variâncias:\n\n```{r}\n# Teste de Bartlett – mais sensível a desvios da normalidade\nbartlett.test(tcm ~ especie, data = micelial)\n```\n\n```{r}\n# Teste de Levene – mais robusto à violação da normalidade\nlibrary(car)\nleveneTest(tcm ~ especie, data = micelial)\n```\n\n##### Interpretação dos Resultados:\n\n-   **p-valor \\> 0,05** → Não há evidência de variâncias diferentes → Premissa atendida.\n\n-   **p-valor \\< 0,05** → As variâncias são significativamente diferentes → Premissa violada.\n\n#### Comparações múltiplas e médias ajustadas\n\n**Pacote “emmeans”**\n\n(“*estimated marginal means*”, ou médias marginais estimadas) é usado para realizar testes de comparação de médias entre grupos, ajustando para outros fatores importantes que podem influenciar as médias. O pacote é particularmente útil em modelos lineares generalizados (GLM).\n\n`emmeans(...)`: calcula as médias ajustadas (médias marginais) para cada grupo de `especie` com base no modelo.\n\nImportante para comparações entre grupos quando há mais de 2 níveis.\n\n```{r}\nlibrary(emmeans)\nm <- emmeans(aov2, ~ especie)\nm\n```\n\n**Testes post-hoc (comparações entre grupos)**\n\n**Pacote “multcomp” -** `multcomp`: para fazer comparações múltiplas entre grupos.\n\nTestes simultâneos e intervalos de confiança para hipóteses lineares gerais em modelos paramétricos, incluindo efeitos lineares, lineares generalizados, lineares mistos e modelos de sobrevivência.\n\n**Pacote “multcompView” -** `multcompView`: para gerar **letras compactas**, indicando quais grupos são diferentes.\n\nConverte um vetor lógico ou um vetor de valores-*p* ou uma matriz de correlação, diferença ou distância em uma exibição identificando os pares para os quais as diferenças não foram significativamente diferentes.\n\n**Cld -** Extrai e exibe informações sobre todas as comparações pareadas de médias de mínimos quadrados.\n\n```{r}\nlibrary(multcomp)\nlibrary(multcompView)\n\ncld(m)\n```\n\n```{r}\npairs(m) #Mostra os testes pareados (comparação entre pares de grupos).\n```\n\n```{r}\npwpm(m) #Exibe uma matriz com as médias na diagonal e comparações entre os grupos fora dela.\n```\n\n## ANOVA fatorial (two-way ANOVA)\n\nA ANOVA fatorial é utilizada quando há duas ou mais variáveis independentes (fatores), cada uma com dois ou mais níveis. Ela é apropriada para experimentos fatoriais completos, nos quais todas as combinações possíveis entre os níveis dos fatores são testadas. Além de avaliar os efeitos individuais de cada fator, essa análise também permite verificar se existe interação entre os fatores, ou seja, se o efeito de um fator depende dos níveis do outro.\n\n### Importando o conjunto de dados:\n\nBanco de dados utilizado: fungicida-vaso (conjunto de dados do dados diversos). Objeto nomeado como fung_vaso.\n\n```{r}\nlibrary(tidyverse)\nlibrary(readxl)\n\nfung_vaso <- read_xlsx(\"dados-diversos.xlsx\", sheet = \"fungicida_vaso\")\n```\n\n**`factor(dose)`**: converte a variável `dose` em fator (categórica);\n\n**`severity * 100`**: transforma a variável de severidade em percentual;\n\n**`geom_jitter()`**: mostra os pontos com leve deslocamento horizontal, evitando sobreposição;\n\n**`facet_wrap(~ treat)`**: separa os gráficos por tratamento (`treat`).\n\n```{r}\nfung_vaso |> \n  ggplot(aes(factor(dose), severity*100))+ #transformando dose em um fator e ##transformar para percentual *100\n  geom_jitter(width = 0.1)+\n  facet_wrap(~ treat)\n```\n\n### Modelo linear com interação\n\n```{r}\nm_anti <- lm(severity ~ treat * dose, data = fung_vaso)\nanova(m_anti)\n```\n\n#### Checagem das premissas e visualização com DHARMa:\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m_anti))\n```\n\n#### Médias ajustadas com `emmeans`\n\n```{r}\nmedia_anti <- emmeans(m_anti, ~ treat | dose)\nmedia_anti\n```\n\n#### Comparações múltiplas\n\n```{r}\ncld(media_anti)\n```\n\n##### Agora inverte: médias de doses dentro de tratamentos\n\n```{r}\nmedia_anti <- emmeans(m_anti, ~ dose | treat)\nmedia_anti\ncld(media_anti)\n```\n\n#### Coeficiente de variação\n\nEssa função do pacote `agricolae` calcula o coeficiente de variação (CV%) do modelo.\n\nAjuda a avaliar a precisão experimental. Valores abaixo de 20% geralmente são considerados bons (mas depende do contexto).\n\n```{r}\nlibrary(agricolae)\ncv.model(m_anti)\n```\n\n#### E se não houver interação significativa?\n\nMostra os efeitos **individuais de dose e tratamento**, ignorando a interação.\n\n```{r}\nlibrary(patchwork)\n\np1 <- fung_vaso |> \n  ggplot(aes(factor(dose), severity*100)) + \n  geom_jitter(width = 0.1)\np2 <- fung_vaso |> \n  ggplot(aes(treat, severity*100)) + \n  geom_jitter(width = 0.1)\np1 + p2\n```\n\n#### Visualização da interação\n\n-   Gera um gráfico de interação;\n\n-   Se as linhas forem paralelas, não há interação;\n\n-   Se forem cruzadas ou afastadas, pode indicar interação.\n\n```{r}\ninteraction.plot(fung_vaso$treat, fung_vaso$dose, fung_vaso$severity)\n```\n\nTabela\n\n|          | 0.5     | 0.2    |\n|----------|---------|--------|\n| LI       | 29.2 Aa | 5.0 Ab |\n| TEBU     | 2.1 Ba  | 2.0 Aa |\n| cv = 63% |         |        |\n\n### Exemplo:\n\n#### Pacote `epifitter` e dados:\n\n```{r}\n#install.packages(\"epifitter\")\nlibrary(epifitter)\noidio <- PowderyMildew\n```\n\n#### Visualização dos dados filtrados\n\nFiltra apenas 3 tipos de irrigação.\n\n`sev*100`: transforma a severidade (que vai de 0 a 1) para percentual (0–100%).\n\n`facet_grid(moisture ~ irrigation_type)`: cria um painel com um gráfico para cada combinação de `moisture` (umidade) e `irrigation_type` (tipo de irrigação).\n\nO gráfico mostra como a doença evolui ao longo do tempo (`time`).\n\n```{r}\noidio |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\")) |> \n  ggplot(aes(time, sev*100)) + \n  geom_jitter(width = 0.1) +\n  facet_grid(moisture ~ irrigation_type)\n```\n\n#### Cálculo da AUDPC (Área Abaixo da Curva de Progresso da Doença)\n\n`group_by(...)` agrupa os dados por tratamento (irrigação, umidade e bloco);\n\n`AUDPC(...)` calcula a área abaixo da curva para cada grupo;\n\nA AUDPC resume a intensidade da doença ao longo do tempo.\n\n```{r}\nlibrary(dplyr)\nlibrary(epifitter)\n\noidio3 <- oidio |>\n  group_by(irrigation_type, moisture, block) |>\n  summarise(AUDPC = AUDPC(time, sev), .groups = \"drop\")\n```\n\n#### Visualizando a AUDPC\n\n```{r}\noidio3 |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\")) |>\n  ggplot(aes(irrigation_type, AUDPC, color = moisture)) +\n  geom_point(width = 0.1) +\n  scale_y_continuous(limits = c(0, 20))\n```\n\n#### ANOVA fatorial (efeito da irrigação e umidade na AUDPC)\n\n```{r}\noidio4 <- oidio3 |> \n  filter(irrigation_type %in% c(\"MS\", \"MS above canopy\", \"Overhead\"))\n\nanov_oidio <- lm(AUDPC ~ irrigation_type * moisture, data = oidio4)\nanova(anov_oidio)\n```\n\n#### Diagnóstico do modelo\n\n```{r}\nplot(simulateResiduals(anov_oidio))\n```\n\n#### Médias ajustadas com `emmeans`\n\n```{r}\nmedias_oidio <- emmeans(anov_oidio, ~ irrigation_type | moisture)\nmedias_oidio\ncld(medias_oidio)\n```\n\nAgora, inverte: mostra as médias de umidade dentro de cada tipo de irrigação.\n\n```{r}\nmedias_oidio2 <- emmeans(anov_oidio, ~ moisture | irrigation_type)\nmedias_oidio2\ncld(medias_oidio2)\n```\n\n#### Coeficiente de variação do modelo\n\nIndica a precisão do experimento - valores menores geralmente indicam maior confiabilidade\n\n```{r}\ncv.model(anov_oidio)\n```\n\nTabela\n\n|           | H. moisture | M. moisture |\n|-----------|-------------|-------------|\n| MS        | 8.52 Aa     | 11.18 Ab    |\n| MS Ac.    | 3.99 Ba     | 4.86 Bb     |\n| Overhead  | 3.68 Ba     | 3.81 Ca     |\n| CV = 6.41 |             |             |\n\n## Anova Fatorial - 3 Fatores\n\n### Exemplo:\n\nDados sobre a interação entre tipo de armazenamento e umidade.\n\n```{r}\nmilho <- read_excel(\"dados-diversos.xlsx\", \"armazena\")\nmilho |>\n  filter(tempo ==8) |>\n  ggplot(aes(factor(tipo), peso_mil,\n             color = factor(umidade)))+\n  geom_jitter(width = 0.1)+\n  facet_wrap(~ umidade)\n```\n\nTestar a interação entre o tipo de armazenamento e o tempo 8\n\n```{r}\nmilho2 <- milho |>\n  filter(tempo ==8)\n\nm2 <- aov(peso_mil ~ factor(tipo)*factor(umidade),\n          data = milho2)\nsummary(m2)\n```\n\nTestanto tipo de inoculação na incidencia de *Fusarium* sp. em milho\n\n```{r}\nmilho3 <- read_excel(\"dados-diversos.xlsx\", \"milho\")\n\nm4 <- aov(yield ~hybrid*method,\n          data = milho3)\nsummary(m4)\n```\n\nChecagem das premissas\n\n```{r}\ncheck_heteroscedasticity(m4)\n```\n\n```{r}\nplot(simulateResiduals(m4))\n```\n\nMédias ajustadas com `emmeans`\n\n```{r}\nmedias_m4 <- emmeans(m4, ~ hybrid)\nmedias_m4\n```\n\n```{r}\ncld(medias_m4)\n```\n\nCaso a interação não dê sifnificativa, tira a interação e deixa só o fator que teve significancia (isola o fator)\n\n```{r}\nm5 <- aov(yield ~hybrid, data = milho3)\nsummary(m5)\n```\n\n```{r}\nm4 <- aov(yield ~hybrid,\n          data = milho3)\nsummary(m5)\n```\n\n```{r}\ncheck_heteroscedasticity(m5)\n```\n\n```{r}\nmedias_m5 <- emmeans(m5, ~hybrid)\nmedias_m5\n```\n\n```{r}\ncld(medias_m5)\n```\n\n```{r}\npwpm(medias_m5)\n```\n\n## **ANOVA com bloco**\n\n### **Anova com bloco - Delineamento em Blocos Casualizado (DBC)**\n\nO (DBC) envolve os três princípios da experimentação: repetição, casualização e controle local. Neste caso, as condições locais não são homogêneas e podem ter efeito significativo sobre os tratamentos.\n\n#### Carregando pacotes e dados\n\nUsando o conjunto de dados fungicida_campo\n\n```{r}\nlibrary(readxl)\nlibrary(Hmisc)\nfung_campo <- read_xlsx(\"dados-diversos.xlsx\", sheet = \"fungicida_campo\")\n```\n\n#### Gráfico de produção por tratamento\n\n`mutate(TRAT = factor(TRAT))`: transforma os tratamentos (TRAT) em fatores para garantir que o `ggplot` os trate como categorias.\n\n`geom_jitter`: mostra os dados de cada parcela/bloco, deslocados horizontalmente para evitar sobreposição.\n\n`stat_summary(fun.data = \"mean_cl_boot\")`: adiciona médias com intervalos de confiança via bootstrap.\n\n```{r}\nfung_campo |> \n  mutate(TRAT = factor(TRAT)) |> \n  ggplot(aes(TRAT, PROD)) +\n  geom_jitter(width = 0.2) +\n  stat_summary(fun.data = \"mean_cl_boot\", colour = \"red\", width = 0.3)\n\n```\n\n#### Convertendo variáveis em fatores\n\nAqui, você transforma `TRAT` e `BLOCO` explicitamente em **fatores**, pois o R trata números como contínuos por padrão.\n\n```{r}\nfung_campo$TRAT <- factor(fung_campo$TRAT)\nfung_campo$BLOCO <- factor(fung_campo$BLOCO)\n```\n\n#### **Modelo Anova com bloco**\n\nANOVA com efeito de blocos e tratamentos:\n\n```{r}\nanova_campo <- lm(PROD ~ BLOCO + TRAT, data = fung_campo)\nanova(anova_campo)\n\n```\n\n#### Checagem das premissas\n\n```{r}\nlibrary(performance)\nlibrary(DHARMa)\ncheck_normality(anova_campo)\ncheck_heteroscedasticity(anova_campo)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(anova_campo))\n```\n\n#### Estimativa e comparação das médias dos tratamentos\n\n```{r}\nmeans_campo <- emmeans(anova_campo, ~ TRAT)\nmeans_campo\n```\n\n```{r}\nlibrary(multcomp)\ncld(means_campo)\n```\n\n```{r}\nplot(means_campo)\npwpp(means_campo)\npwpm(means_campo)\n```\n\nAnálise da Severidade da Ferrugem (`FER`):\n\n#### ANOVA com transformação logarítmica\n\n```{r}\nanova_fer <- lm(log(FER) ~ BLOCO + TRAT, data = fung_campo)\nanova(anova_fer)\n```\n\n#### Diagnóstico do modelo\n\n```{r}\nplot(simulateResiduals(anova_fer))\n```\n\n#### Médias com back-transformation\n\n```{r}\nmeans_fer <- emmeans(anova_fer, ~ TRAT, type = \"response\")\n```\n\n```{r}\ncld(means_fer)\nplot(means_fer)\npwpp(means_fer)\npwpm(means_fer)\n```\n\n## **Delineamento em parcela subdividida (*Split-plot*)**\n\n### Importando o conjunto de dados:\n\nExemplo:\n\n```{r}\nmilho <- read_excel(\"dados-diversos.xlsx\", \"milho\")\n```\n\n#### Visualizando os dados\n\n```{r}\nmilho |> \n  \n  ggplot(aes(hybrid, index, color = method))+\n  geom_jitter(width = 0.1)+\n coord_flip()\n```\n\n#### **Ajustando o modelo**:\n\n```{r}\naov_milho_bloco <- aov(index ~ factor(block) + hybrid*method + \nError(factor(block)/hybrid/method), data = milho)\n\nsummary(aov_milho_bloco)\n```\n\n#### **Checagem das premissas**\n\nEm parcelas subdivididas não é possível checar as premissas pelo check\\_, então usa lme4, para checar pelo modelo misto.\n\n##### **Pacote “lme4”**\n\nAjusta modelos de efeitos mistos lineares e lineares generalizados. Os modelos e seus componentes são representados usando classes e métodos S4.\n\n##### **Função “lmer”**\n\nGera um componente aleatório que é específico a cada indivíduo, de modo que podemos ter, para cada um, um intercepto e uma inclinação distintas.\n\n```{r}\nlibrary(Matrix)\nlibrary(lme4)\nmilho$block <- as.factor(milho$block)\nmix2 <- lmer(index ~ block + hybrid*method + \n(1|block/hybrid), data =  milho)\n\nlibrary(car)\nAnova(mix2)\n```\n\n```{r}\ncheck_normality(mix2)\n```\n\n```{r}\ncheck_heteroscedasticity(mix2)\n```\n\n#### Necessário transformar os dados\n\n```{r}\nmilho$block <- as.factor(milho$block)\nmix2 <- lmer(sqrt(index) ~ block + hybrid*method + (1|block/hybrid), data = milho)\nlibrary(car)\nAnova(mix2)\n```\n\n##### Checagem\n\n```{r}\ncheck_normality(mix2)\n```\n\n```{r}\ncheck_heteroscedasticity(mix2)\n```\n\n#### **Comparação de médias**\n\n```{r}\nmeans_mix2 <- emmeans(mix2, ~hybrid | method)\nmeans_mix2\n```\n\n```{r}\ncld(means_mix2)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"anova.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","author":"Daiane Rocha Fernandes","editor":"visual","theme":{"light":"minty","dark":"darkly"},"message":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}